% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gsv4_object.R
\name{gsv4_InterpolationPoint}
\alias{gsv4_InterpolationPoint}
\title{gsv4_InterpolationPoint}
\usage{
gsv4_InterpolationPoint(color = NULL, type = NULL, value = NULL)
}
\arguments{
\item{color}{\code{\link{gsv4_Color}} object. Represents a color in the RGBA color space. This representation is designed
for simplicity of conversion to/from color representations in various
languages over compactness; for example, the fields of this representation
can be trivially provided to the constructor of "java.awt.Color" in Java; it
can also be trivially provided to UIColor's "+colorWithRed:green:blue:alpha"
method in iOS; and, with just a little work, it can be easily formatted into
a CSS "rgba()" string in JavaScript, as well. Here are some examples:

Example (Java):

     import com.google.type.Color;

     // ...
     public static java.awt.Color fromProto(Color protocolor) {
       float alpha = protocolor.hasAlpha()
           ? protocolor.getAlpha().getValue()
           : 1.0;

       return new java.awt.Color(
           protocolor.getRed(),
           protocolor.getGreen(),
           protocolor.getBlue(),
           alpha);
     }

     public static Color toProto(java.awt.Color color) {
       float red = (float) color.getRed();
       float green = (float) color.getGreen();
       float blue = (float) color.getBlue();
       float denominator = 255.0;
       Color.Builder resultBuilder =
           Color
               .newBuilder()
               .setRed(red / denominator)
               .setGreen(green / denominator)
               .setBlue(blue / denominator);
       int alpha = color.getAlpha();
       if (alpha != 255) {
         result.setAlpha(
             FloatValue
                 .newBuilder()
                 .setValue(((float) alpha) / denominator)
                 .build());
       }
       return resultBuilder.build();
     }
     // ...

Example (iOS / Obj-C):

     // ...
     static UIColor* fromProto(Color* protocolor) {
        float red = [protocolor red];
        float green = [protocolor green];
        float blue = [protocolor blue];
        FloatValue* alpha_wrapper = [protocolor alpha];
        float alpha = 1.0;
        if (alpha_wrapper != nil) {
          alpha = [alpha_wrapper value];
        }
        return [UIColor colorWithRed:red green:green blue:blue alpha:alpha];
     }

     static Color* toProto(UIColor* color) {
         CGFloat red, green, blue, alpha;
         if (![color getRed:&red green:&green blue:&blue alpha:&alpha]) {
           return nil;
         }
         Color* result = [Color alloc] init];
         [result setRed:red];
         [result setGreen:green];
         [result setBlue:blue];
         if (alpha <= 0.9999) {
           [result setAlpha:floatWrapperWithValue(alpha)];
         }
         [result autorelease];
         return result;
    }
    // ...

 Example (JavaScript):

    // ...

    var protoToCssColor = function(rgb_color) {
       var redFrac = rgb_color.red || 0.0;
       var greenFrac = rgb_color.green || 0.0;
       var blueFrac = rgb_color.blue || 0.0;
       var red = Math.floor(redFrac * 255);
       var green = Math.floor(greenFrac * 255);
       var blue = Math.floor(blueFrac * 255);

       if (!('alpha' in rgb_color)) {
          return rgbToCssColor_(red, green, blue);
       }

       var alphaFrac = rgb_color.alpha.value || 0.0;
       var rgbParams = [red, green, blue].join(',');
       return ['rgba(', rgbParams, ',', alphaFrac, ')'].join('');
    };

    var rgbToCssColor_ = function(red, green, blue) {
      var rgbNumber = new Number((red << 16) | (green << 8) | blue);
      var hexString = rgbNumber.toString(16);
      var missingZeros = 6 - hexString.length;
      var resultBuilder = ['#'];
      for (var i = 0; i < missingZeros; i++) {
         resultBuilder.push('0');
      }
      resultBuilder.push(hexString);
      return resultBuilder.join('');
    };

    // ...}

\item{type}{string. How the value should be interpreted. type must take one of the following values: INTERPOLATION_POINT_TYPE_UNSPECIFIED, MIN, MAX, NUMBER, PERCENT, PERCENTILE
See the details section for the definition of each of these values.}

\item{value}{string. The value this interpolation point uses.  May be a formula.
Unused if type is MIN or
MAX.}
}
\value{
InterpolationPoint
}
\description{
A single interpolation point on a gradient conditional format.
These pin the gradient color scale according to the color,
type and value chosen.
}
\details{
type takes one of the following values:
\itemize{
 \item{INTERPOLATION_POINT_TYPE_UNSPECIFIED - The default value, do not use.}
 \item{MIN - The interpolation point will use the minimum value in the
cells over the range of the conditional format.}
 \item{MAX - The interpolation point will use the maximum value in the
cells over the range of the conditional format.}
 \item{NUMBER - The interpolation point will use exactly the value in
InterpolationPoint.value.}
 \item{PERCENT - The interpolation point will be the given percentage over
all the cells in the range of the conditional format.
This is equivalent to NUMBER if the value was:
`=(MAX(FLATTEN(range)) * (value / 100))
  + (MIN(FLATTEN(range)) * (1 - (value / 100)))`
(where errors in the range are ignored when flattening).}
 \item{PERCENTILE - The interpolation point will be the given percentile
over all the cells in the range of the conditional format.
This is equivalent to NUMBER if the value was:
`=PERCENTILE(FLATTEN(range), value / 100)`
(where errors in the range are ignored when flattening).}
}
}
\seealso{
\href{https://developers.google.com/sheets/reference/rest/v4/spreadsheets#InterpolationPoint}{Google's Documentation for InterpolationPoint}
}

